\documentclass[a4paper, 11pt]{article}

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

\usepackage{comment} % enables the use of multi-line comments (\ifx \fi) 
\usepackage{lipsum} %This package just generates Lorem Ipsum filler text. 
\usepackage{fullpage} % changes the margin
\usepackage[utf8]{inputenc}
\usepackage{gensymb}
\usepackage{graphicx}
\usepackage{booktabs}% http://ctan.org/pkg/booktabs
\usepackage{makecell}
\usepackage{tabularx}
\usepackage[table]{xcolor}
\usepackage{array}
\usepackage{wrapfig}
\usepackage{subcaption}
\usepackage{csquotes}
\usepackage{lscape}
\usepackage{afterpage}
\usepackage{geometry}
\usepackage{listingsutf8}
\usepackage{chngcntr}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{pifont}


\counterwithin{figure}{section}

\geometry{a4paper, margin=1in}
\renewcommand{\figurename}{Abb.}
\renewcommand{\tablename}{Tabelle}
\newcommand{\code}[1]{\texttt{#1}}

\renewcommand*{\thead}[1]{\bfseries #1}

\renewcommand{\contentsname}{Inhalt}
\renewcommand{\listfigurename}{Abbildungsverzeichnis}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{darkgreen}{rgb}{0.05,0.56,0.06}

\lstdefinelanguage{JavaScript}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{darkgreen}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}


\lstset{frame=tlrb,
	language=JavaScript,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numbers=left,
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{violet},
	stringstyle=\color{darkgreen},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3,
	literate=%
	{Ö}{{\"O}}1
	{Ä}{{\"A}}1
	{Ü}{{\"U}}1
	{ß}{{\ss}}1
	{ü}{{\"u}}1
	{ä}{{\"a}}1
	{ö}{{\"o}}1
}

\begin{document}
	
\title{Zusammenfassung WEBAPP FS2018}
\author{Alex Neher}
\maketitle

\tableofcontents
\newpage

\graphicspath{{./Pictures/}}

\section{Einführung}
\subsection{Technologien LAMP/MEAN Stack}
\begin{minipage}{0.45\textwidth}
	\begin{description}
		\item[L] inux
		\item[A] pache
		\item[M] ySQL
		\item[P] HP
	\end{description}
\end{minipage} \hfil
\begin{minipage}{0.45\textwidth}
	
	\begin{description}
		\item[M] ongoDB
		\item[E] xpress
		\item[A] ngularJS
		\item[N] odeJS
	\end{description}

\end{minipage}

\section{JavaScript}
\subsection{Grundlegende Sprachkonzepte}
Javascript, auch ECMAScript genannt ist eine clientseitige web-Development Sprache für DOM- und CSS-Manipulation, AJAX oder EventHandling. Javascript kann in HTML-Code eingebunden werden, entweder inline über \code{<script></script>}-Tags, es kann mittels \\
\code{<script src=path/to/file.js></script>} geholt werden oder direkt über EventHandler \code{<input type="checkbox" name="options" onchange="order.options.giftwrap = this.checked;">}. 


\subsubsection{Variablen definieren}
Javascript hat keine Typisierung. Das heisst, Variablen können einfach mit dem Keyword \code{var} definiert werden, ohne dass ein Datentyp spezifiziert werden muss.

\begin{lstlisting}
var a = 2;  // a ist nun eine Nummer
a = 'Jetzt bin ich ein String';
a = false;
\end{lstlisting}

\subsubsection{Arrays}

\begin{lstlisting}
//Instanziierung von Arrays über var
var emptyArray = [];
var numberArray = [1, 3, 6];

//Instanziierung von Arrays über new
var anotherEmptyArray = new Array();
var arrayOfFive = new Array(5);

//Da JavaScript keine Typisierung kennt, sind auch gemsiche Arrays möglich
var mixedArray = ["String", 4, true];

//Es können auch Objekte in Arrays verpackt werden
var modulesArray = [
	{title:"WEBAPP", instructor:"Koller"}, 
	{title:"WEBTEC", instructor:"Infanger"}
];

//Zugriff und hinzufügen von Array-Elemente erfolgt gleich wie bei bekannten Sprachen
console.log(numberArray[0]) //1
numberArray[3] = "new Element"

//Arrays müssen nicht zwingend ganz gefüllt sein
var sparseArray = new Array(1000);
console.log(sparseArray[500]); //undefined
\end{lstlisting}

\subsubsection{Objekte}
JavaScript kann auch objektbasiert programmiert werden. Es gibt grundsätzlich vier Möglichkeiten, Objekte zu instanziieren:

\begin{lstlisting}
//1. über "var"
var bachelorModule = {
	title: "Webapplication Development",
	instructor: "Thomas Koller"
};

//2. über new und dem default-Konstruktor
var bachelorModule = new Object();

//3. über Object.create()
var bachelorModule = Object.create(Object.prototype); //ein leeres Objekt

//4. mit einem bereits bestehenden Objekt als Prototyp
var masterModule = Object.create(bachelorModule) //ist jetzt ein "Klon" von bachelorModule
\end{lstlisting}

Der Zugriff auf Properties funktioniert wie bei anderen objektorientierten Sprachen

\begin{lstlisting}
console.log(bachelorModule.title);  //Output: Webapplication Development
console.log(bachelorModule["instructor"]); //Output: Thomas Koller
\end{lstlisting}

Objekte sind dynamisch. Das heisst, es können zur Laufzeit noch Properties hinzugefügt oder entfernt werden:

\begin{lstlisting}
//hinzufügen von Properties
bachelorModule.credits = 3;

//entfernen von Properties
delete bachelorModule.credits;

//Ebenfalls kann gecheckt werden, ob ein Property existiert
bachelorModule.hasOwnProperty("title"); //true
bachelorModule.hasOwnProperty("credits"); //false
\end{lstlisting}
\subsection{Funktoinsdeklarationen und -aufruf}
In Javascript werden Funktionen als Objekte behandelt. Sie können ebenfalls mit dem Keyword \code{var} erstellt werden. Jede Funktion hat ihren eigenen Kontext/Scope. Jede Funktion hat per Default zwei Parameter: \code{this} und \code{arguments}.

Der \code{this} Parameter gibt den Kontext der Funktion zurück. Dieser hängt davon ab, wie und wo die Funktion aufgerufen wird. \code{arguments} ist ein Array, in welchem alle mitgegebenen Argumente speichert.

\begin{lstlisting}
//1. Über anonymes Function Literal
var add = function(a,b){
	console.log(arguments[0]) //gibt den Wert von a zurück
	return a+b;
}

//2. Über Function Literal mit Name
var sub = function sub(a,b){
	return a-b;
}

//3. Über Function Declaration
function mult(a,b){
	return a*b;
}

//4. Über Immediate Function Invocation
var TenDividedByTwo = function(a,b){return a/b;}(10,5);
console.log(TenDividedByTwo) //Output: 5
\end{lstlisting}

Funktionen können auch direkt in Objekten definiert werden
\begin{lstlisting}
var person = {
	firstName = "Thomas",
	lastName = "Koller",

	printFullName: function(){
		console.log(this.firstName + " " + this.lastName);
	};
}

person.printFullName();
\end{lstlisting}

Mit dem 'apply'-Pattern können auch Funktionen von anderen Objekten aufgerufen werden

\begin{lstlisting}
var anotherPerson = {
	firstName = "Donald",
	lastName = "Trump"
}

anotherPerson.printFullName() //error: undefined

aPerson.printFullName.apply(anotherPerson); //Output: Donald Trump
\end{lstlisting}

\subsection{Closures}
Wie bereits erwähnt, werden Funktionen als Objekte behandelt und haben ihren eigenen Kontext/Scope. Das heisst, von ausserhalb kann nicht direkt auf Variablen innerhalb einer Funktion zugegriffen werden, sondern nur über verschachtelte Funktionen. Dieses Konstrukt nennt man \textbf{Closure}.

\begin{lstlisting}
var myCounter = (function(){
	var value = 0;
	return {
		increment: function(inc){
			value =+ inc;
		},
		getValue: function(){
			return value;
		}
	};
}());

myCounter.increment(10) //value = 10
console.log(myCounter.value); //error: undefined
console.log(myCounter.getValue()); //10
\end{lstlisting}

\subsection{Prototypen und Konstruktoren}
\subsubsection{Konstruktoren}
JavaScript hat, wie auch andere objektorientierten Sprachen, Konstruktoren (die immer gross geschrieben werden)

\begin{lstlisting}
function Name(vorname, nachname){
	this.vorname = vorname;
	this.nachname = nachname;
	this.birthDate = {
		year: 0,
		month: 0,
		day: 0
	}
}
\end{lstlisting}

\subsubsection{Prototypen}

\noindent Wie bereits im Kapitel 'Funktionen' beschrieben, können Funktionen direkt in Objekten definiert werden. Dann existieren sie jedoch nur für diese eine Objekt (z.B. dem Objekt aPerson). Wenn ich nun eine Funktion definieren will, die für alle \code{Name}-Objekte existiert, muss ich sie mithilfe dem \code{prototype}-Keyword definieren.

\begin{lstlisting}
Name.prototype.hello = function(){
	console.log("Hello " + this.vorname); 
}

var aPerson = new Name("Thomas", "Koller");
aPerson.hello();
\end{lstlisting}

Diese Methode funktioniert, da jedes Objekt ein Prototype hat. Wenn ein gesuchtes Property nicht im Objekt-eigenen Prototype gefunden, so wird rekursiv im Prototype des Prototype-Objekts gesucht, bis man ganz oben bei \code{Object} angekommen ist. Falls dort immer noch nichts gefunden wurde, wird \code{null} zurückgegeben. 

Wenn ein Objekt mithilfe der \code{Object.create()}-Methode instanziiert wird, so hat das neu erstellte Objekt den Prototypen des mitgegebenen Objekts.

\begin{lstlisting}
var obj1 = {
	a: 1
}

var obj2 = Object.create(obj1); //Der Prototyp von obj2 ist jetzt obj1

console.log(obj2.a) //Output: 1
\end{lstlisting}

\code{obj2} selbst hat kein 'a'-Property, es wird also eine Stufe höher gesucht, im Property von \code{obj2}, also \code{obj1}


\subsection{Asynchrone Programmierung}
Mittels den Methoden \code{long setInterval(function f, unsigned long interval, any args)} und \code{long setTimeOut(function f, unsigned long timeout, any args)} kann die Ausführung der übergebenen Methode verzögert (setTimeOut) oder in einem definierten Intervall wiederholt (setInterval) werden. Die Ausführung der Methode \code{f} wird um \code{timeout} Millisekunden verzögert bzw. nach \code{interval} Millisekunden wiederholt.

\subsection{Promises}

\section{Client Side JavaScript}
\subsection{JavaScript Verarbeitung / Event Handling}
\begin{wrapfigure}[18]{R}{0.75\textwidth}
	\centering
	\includegraphics[keepaspectratio=true,height=15\baselineskip]{js_ausfuehrung.jpg}
	\caption{Verschiedene Arten, wie JS verarbeitet werden kann}
	\label{fig:rel}
\end{wrapfigure}
JavaScript kann normal, asynchron oder deferred ausgeführt werden. Bei der normalen Verarbeitung wird das HTML-Parsing pausiert, das JS-Skript heruntergeladen, kompiliert und ausgeführt und erst anschliessend mit dem HTML-Parsing weitergemacht. Wenn man die asynchrone Verarbeitung wählt, wird das JS-Skript im Hintergrund heruntergeladen. Erst wenn das Skript heruntergeladen wurde, wird das HTML-Parsing pausiert und das Skript wird ausgeführt. Bei der deferred-Methode wird das Skript ebenfalls im Hintergrund heruntergeladen. Jedoch wird hier gewartet, bis das gesamte HTML-Parsing abgeschlossen ist, bevor das Skript ausgeführt wird.

\subsection{Konzept DOM / CSS Manipulation}
\subsubsection{DOM-Manipulation}
\begin{figure}[htb]
	\centering
	\includegraphics[keepaspectratio=true,height=14\baselineskip]{DOM_structure.jpg}
	\caption{Beispiel eines DOM-Baumes}
	\label{fig:DOM}
\end{figure}
DOM steht für \textit{Document Object Model} und bezeichnet die Struktur einer HTML-Website. Alle Objekte der Website werden in der Baumstruktur des DOMs als Node abgespeichert. JavaScript kann direkt auf diese Nodes zugreifen z.B. wäre \code{"simple"} in Abb. \ref{fig:DOM} mittels \code{document.childNodes[0].childNodes[1].lastChild.firstChild.nextSibling.childNodes[0]} erreichbar. Da dies jedoch ein bisschen umständlich ist, werden im nächsten Kapitel einige einfachere Selektions-Methoden vorgestellt.

%TODO: Add Document Structure (Lecture Javascript Client Side, P23ff)

Wie bereits zu Beginn des Kapitels erwähnt, wird JavaScript unter anderem zur DOM-Manipulation verwendet. Um Elemente des DOM manipulieren zu können, muss dem Skript zuerst mitgeteilt werden, welches Element man manipulieren möchte. Dabei gibt es verschiedene Methoden:

\subparagraph{Über ID (empfohlen)}\mbox{}\\
\begin{lstlisting}
var button = document.getElementById("button1")
\end{lstlisting}

\begin{lstlisting}[language=html]
<button id="button1">Click me!</button>
\end{lstlisting}

\subparagraph{Über Namen}\mbox{}\\
Diese Methode gibt eine NodeList zurück mit allen gefundenen Elementen
\begin{lstlisting}
var buttons = document.getElementsByName("option_buttons")
console.log(buttons[0].tagName) //Output: button
\end{lstlisting}
\begin{lstlisting}[language=html]
<button name="option_button">Pizza Margharita</button>
<checkbox name="option_button">Pizza Diavola</checkbox>
\end{lstlisting}

\subparagraph{Über Tags}\mbox{}\\
Funktioniert gleich wie \code{getElementsByName} aber filtert nach HTML-Tags
\begin{lstlisting}
var buttons = document.getElementsByTagName("button")
console.log(buttons[0].name) //Output: option_button
\end{lstlisting}
\begin{lstlisting}[language=html]
<button name="option_button">Pizza Margharita</button>
\end{lstlisting}

\subparagraph{Über Klasse(n)}\mbox{}\\
Gibt eine HTML-Collection zurück. Falls mehrere Klassen spezifiziert werden, muss das Element Mitglied \textit{aller} Klassen sein
\begin{lstlisting}
var buttons = document.getElementsByClassName("options")
console.log(buttons[0].name) //Output: option_button
\end{lstlisting}
\begin{lstlisting}[language=html]
<button class="options">Pizza Margharita</button>
\end{lstlisting}

\subparagraph{Über CSS-Selektoren}\mbox{}\\
Nur kompatibel mit HTML5. Gibt eine NodeList zurück.
\begin{lstlisting}
var logs = document.querySelectorAll("#log>span)
\end{lstlisting}
\begin{lstlisting}[language=html]
<div id=span>
<span>I'm selected</span>
</div>
\end{lstlisting}
\subsection{JQuery}
JQuery ist eines der inzwischen hunderten von JavaScript Frameworks. Genau wie JavaScript kann mit JQuery ebenfalls DOM- und CSS-Manipulation durchgeführt, sowie Browser Events und AJAX-Requests behandelt werden.

\vspace{10px}

\noindent JQuery Funktionen werden mittels \code{jQuery()} bzw. \code{\$()} aufgerufen. Da jede jQuery-Methode ein jQuery-Object zurückgibt, können beliebig viele Methoden aneinandergehängt werden (ob das leserlich ist, ist eine andere Frage):

\begin{lstlisting}
$("p.details").css("background-color","yellow").show("fast");
\end{lstlisting}
Die obenstehende jQuery-Methode selektiert alle \code{p}-Elemente der Klasse \code{details} mit der Hintergrundfarbe Gelb und zeigt sie an mit einer schnellen Animation.

\vspace{10px}

\noindent Man kann jQuery Methoden auf vier verschiedene Arten aufrufen:
\begin{enumerate}
	\item Selektion \\
	\code{\$(selector, (optional)context)}
	\item Wrapper\\
	\code{\$(document), \$(window) etc.}
	\item HTML-Elemente\\
	\code{var img = \$("<img>", {src: url, css:{...}})}
	\item Events\\
	\code{\$(function)} $\leftarrow$ ist equivalent zu \code{\$(document).ready(function);}
\end{enumerate}

\vspace{10px}

\noindent jQuery verfügt nur über eine getter/setter Methode. Je nach dem, ob der Methode ein Parameter übergeben wird, fungiert sie als getter oder setter.

\begin{lstlisting}
//Der Methode wird kein Parameter übergeben --> sie gibt den gefundenen Wert zurück
$("#icon").attr("src");

//Der Methode wird zusätzlich noch 'icon.gif' übergeben. --> Sie setzt den Wert
$("#icon").attr("src", "icon.gif");
\end{lstlisting}

\noindent Dasselbe gilt nebst DOM-Manipulation auch für CSS-Manipulation
\begin{lstlisting}
//Kein Wert übergeben --> gibt die Wert von fontWeight zurück
$("h1").css("fontWeight");

//Es werden Parameter übergeben --> setzt den CSS-Style dementsprechend
$("h1").css({
backgroundColor: "black",
textColor: "green",
});
\end{lstlisting}

\noindent jQuery kann auch Text und HTML schreiben und lesen
\begin{lstlisting}
//Gibt den Dokument-Titel zurück
var title = $("head title").text();

//Gibt das HTML des ersten 'h1'-Elementes zurück
var headline = $("h1").html();

//Setzt jede 'h1'-Heading zu 'TITEL'
$("h1").text(TITEL);
\end{lstlisting}

\noindent Mit dem \code{data()}-Attribut kann jQuery von jedem Element beliebig Daten lesen und schreiben. Der Syntax des \code{data()}-Attribut ist \code{jQuery.data(element, key, value)} wobei das \code{element} das DOM-Element ist, mit dem die Daten assoziiert sind, der \code{key} der Name der zu speichernden Daten und der \code{value} recht selbsterklärend der Wert der zu speichernden Daten ist.
\begin{lstlisting}
//Daten speichern.
$.data(div, "test", {
first: "firstText",
pizza: "secondText"
});

//Daten abrufen und als Text im ersten bzw. letzten <span>-Element der Seite setzen
$("span:first").text( jQuery.data(div, "test" ).first);
$("span:last").text( jQuery.data(div, "test" ).pizza);
\end{lstlisting}

\noindent Wie bereits erwähnt, können mit jQuery auch EventHandler programmiert werden. Dabei folgen alle Browser derselben API (ausser alte IE-Versionen, aber das überrascht eigentlich niemanden).
\begin{lstlisting}
$("#imageShrinker").click(
function () {
$("img").animate({height: 0})
}
);
\end{lstlisting}
\noindent Die obenstehende Funktion setzt die Höhe jedes Bildes auf 0 wenn der Button mit der id \code{imageShrinker} geklickt wird. Es gibt eine vordefinierte Liste von Events, auf welche reagiert werden kann wie z.B. \code{click(), keypress(), load(), focus()} etc.

\vspace{10px}

\noindent Das obere Codebeispiel deckt auch eine weitere Möglichkeit von jQuery ab: Es kann Animationen ausführen wie z.B. Elemente anzeigen und verschwinden lassen.

\vspace{10px}

\noindent jQuery kann auch andere Websites oder remote-Scripts laden und ausführen.
\begin{lstlisting}
//Eine externe Seite laden und im übergebenen Element anzeigen
$("#stats").load("status_report.html");

//Ein remote-Script laden
$.getScript("https://trustworthySite.ru.cn/js/totallyNotACryptoMiner.js");

//Ein remote-Script laden und anschliessend ausführen
$.getScript("https://trustworthySite.ru.cn/js/totallyNotACryptoMiner.js", function(){
$(document).mineMonero();
});
\end{lstlisting}

\vspace{10px}

\noindent jQuery kann ebenfalls JSON laden und parsen
\begin{lstlisting}
$.getJSON("https://server.com/data.json", function(data){
//geparste Daten aus data.json verarbeiten
});
\end{lstlisting}

\vspace{10px}

\noindent Es können auch AJAX Request über jQuery gemacht werden
\begin{lstlisting}
$.ajax({
type: "GET", //GET-Request
url: url, //aufzurufende URL
data: null, //es sollen keine Daten mitgegeben werden
dataType: "script", //die Antwort ist ein sofort auszuführendes Script
success: callback //rufe diese Methode auf, wenn alles erledigt ist
});
\end{lstlisting}
\subsection{Tools und Libraries}

\subsection{Modules}

\section{Server Side JavaScript}
\subsection{NodeJS}

\subsection{Express}

\section{TypeScript}

\section{Single Page Application}
\subsection{Konzept}

\subsection{Begriffe}

\section{Angular}
\subsection{Eigenschaften}

\subsection{Organisation einer Angular Applikation}

\section{REST}
\subsection{Eigenschaften}

\subsection{Resourcen und Methoden}

\section{Mobile App}
\subsection{Ionic}

\subsection{Cordova}

\section{Authentifizierung}
\subsection{Standard-Mechanismen}

\subsection{OAuth2.0}

\end{document}